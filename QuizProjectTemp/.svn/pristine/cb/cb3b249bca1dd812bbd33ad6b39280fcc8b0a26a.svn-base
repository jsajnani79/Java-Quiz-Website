package QuizProject.QuizPackage;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

import QuizProject.DBConnection;
import QuizProject.ModelObject;
import QuizProject.QuestionPackage.FillInTheBlankQuestion;
import QuizProject.QuestionPackage.MatchingQuestion;
import QuizProject.QuestionPackage.MultiMultipleChoiceQuestion;
import QuizProject.QuestionPackage.MultipleChoiceQuestion;
import QuizProject.QuestionPackage.OrderedMultiTextQuestion;
import QuizProject.QuestionPackage.PictureResponseQuestion;
import QuizProject.QuestionPackage.Question;
import QuizProject.QuestionPackage.ResponseQuestion;
import QuizProject.QuestionPackage.UnorderedMultiTextQuestion;
import QuizProject.UserPackage.User;

public class Quiz extends ModelObject {
	
	
	//static final constants
	
	private static final int RANKING_DISPLAY_TIME_INTERVAL = 1000 * 60 * 60 * 24 * 15;
	private static final int NUM_HISTORICAL_SCORES = 10;
	private static final int NUM_RECENT_QUIZZES = 3;
	
	
	//constructors
	
	public Quiz(int id, DBConnection connection) {
		super(id, connection);
	}
	
	public void createModelObject(String name, String description, int creatorId, boolean random, boolean multiPage, boolean immediateCorrection) {
		this.createModelObject(name, description, creatorId, random, multiPage, immediateCorrection, null);
	}
	
	protected void createModelObject(String name, String description, int creatorId, boolean random, boolean multiPage, boolean immediateCorrection, ArrayList<Object> additionalParameters) {
		long dateCreated = System.currentTimeMillis();
		ArrayList<Object> parameters = new ArrayList<Object>(Arrays.asList(name, description, creatorId, -1, -1, -1, -1, -1, -1, 0, 0, new ArrayList<String>(), new ArrayList<String>(), new ArrayList<String>(), dateCreated, random, multiPage, immediateCorrection));
		
		if (additionalParameters != null) {
			parameters.addAll(additionalParameters);
		}
		
		super.createModelObject(parameters);
	}
	
	public static int getIdForName(String name, DBConnection connection) {
		int id = 0;
		
		ResultSet rs = connection.executeQuery("SELECT * FROM quizzes WHERE name = \"" + name + "\";");
		try {
			if (rs.next()) {
				id = rs.getInt("id");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return id;
	}
	
	public static ArrayList<Quiz> getMostPopularQuizzes(DBConnection connection) {
		ArrayList<Quiz> quizzes = new ArrayList<Quiz>();
		
		int quizCount = 0;
		ResultSet rs = connection.executeQuery("SELECT * FROM quizzes ORDER BY total_times_taken DESC");
		try {
			while (quizCount < NUM_RECENT_QUIZZES && rs.next()) {
				quizzes.add(new Quiz(rs.getInt("id"), connection));
				quizCount++;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
				
		return quizzes;
	}
	
	public static ArrayList<Quiz> getRecentlyCreatedQuizzes(DBConnection connection) {
		ArrayList<Quiz> quizzes = new ArrayList<Quiz>();
		int quizCount = 0;
		ResultSet rs = connection.executeQuery("SELECT * FROM quizzes ORDER BY date_created DESC");
		try {
			while (quizCount < NUM_RECENT_QUIZZES && rs.next()) {
				quizzes.add(new Quiz(rs.getInt("id"), connection));
				quizCount++;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
				
		return quizzes;
	}
	
	public static ArrayList<Quiz> getAllQuizzes(DBConnection connection) {
		ArrayList<Quiz> quizzes = new ArrayList<Quiz>();
		ResultSet rs = connection.executeQuery("SELECT * FROM quizzes ORDER BY date_created DESC");
		try {
			while (rs.next()) {
				quizzes.add(new Quiz(rs.getInt("id"), connection));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
				
		return quizzes;
	}
	
	//getters and setters for quiz properties 

	public String getName() {
		return this.getString("name");
	}
	
	public void setName(String name) {
		this.setString("name", name);
	}
	
	public String getDescription() {
		return this.getString("description");
	}
	
	public void setDescription(String description) {
		this.setString("description", description);
	}
	
	public User getCreator(){
		return new User(this.getInt("creator_id"), this.getConnection());
	}
	
	public long getDateCreated() {
		return this.getLong("date_created");
	}
	
	public boolean isRandom() {
		return this.getBoolean("is_random");
	}
	
	public boolean isMultiPage() {
		return this.getBoolean("is_multi_page");
	}
	
	public boolean immediateCorrection() {
		return this.getBoolean("immediate_correction");
	}
	
	// Stats
	
	/// these methods should just dynamically get shit from the db instead of storing always
	public int getHighestScore() {
		return this.getInt("highest_score");
	}
	
	public int getLowestScore() {
		return this.getInt("lowest_score");
	}
	
	public long getLongestTime() {
		return this.getLong("longest_time");
	}
	
	public long getShortestTime() {
		return this.getLong("shortest_time");
	}
	
	public long getAverageTime() {
		return this.getLong("average_time");
	}
	
	public int getMeanScore() {
		return this.getInt("mean_score");
	}
	
	public int getTotalTimesTaken() {
		return this.getInt("total_times_taken");
	}
	
	public int getTotalTimeSpentOnQuiz() {
		return this.getInt("total_time_spent_on_quiz");
	}
	
	public ArrayList<Integer> getMostRecentScoreIds() {
		return this.getIntCSV("most_recent_csv");
	}
	
	public ArrayList<Score> getMostRecentScores(){
		ArrayList<Score> mostRecentScores = new ArrayList<Score>();
		ArrayList<Integer> scoreIds = this.getMostRecentScoreIds();
		for(Integer scoreId:scoreIds){
			Score score = new Score(scoreId, this.getConnection());
			mostRecentScores.add(score);
		}
		return mostRecentScores;
	}
	
	public ArrayList<Integer> getBestAllTimeScoreIds() {
		return this.getIntCSV("best_all_time_csv");
	}
	
	public ArrayList<Score> getBestAllTimeScores(){
		ArrayList<Score> bestAllTimeScores = new ArrayList<Score>();
		ArrayList<Integer> scoreIds = this.getBestAllTimeScoreIds();
		for(Integer scoreId:scoreIds){
			Score score = new Score(scoreId, this.getConnection());
			bestAllTimeScores.add(score);
		}
		return bestAllTimeScores;
	}
	
	public ArrayList<Integer> getBestIntervalScoreIds() {
		return this.getIntCSV("best_interval_csv");
	}
	
	public ArrayList<Score> getBestIntervalScores(){
		ArrayList<Score> bestIntervalScores = new ArrayList<Score>();
		ArrayList<Integer> scoreIds = this.getBestIntervalScoreIds();
		for(Integer scoreId:scoreIds){
			Score score = new Score(scoreId, this.getConnection());
			bestIntervalScores.add(score);
		}
		return bestIntervalScores;
	}
	
	public ArrayList<Question> getQuestions() {
		ArrayList<Question> questionSet = new ArrayList<Question>();
		ResultSet rs = this.getConnection().executeQuery("SELECT *"  + " FROM questions WHERE quiz_id = " + this.getID() + ";");
		try {
			while (rs.next()) {
				String questionType = rs.getString("question_type");
				if (questionType.equals(FillInTheBlankQuestion.QUESTION_TYPE)) {
					questionSet.add(new FillInTheBlankQuestion(rs.getInt("id"),this.getConnection()));
				}else if (questionType.equals(MatchingQuestion.QUESTION_TYPE)) {
					questionSet.add(new MatchingQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(MultiMultipleChoiceQuestion.QUESTION_TYPE)) {
					questionSet.add(new MultiMultipleChoiceQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(MultipleChoiceQuestion.QUESTION_TYPE)) {
					questionSet.add(new MultipleChoiceQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(OrderedMultiTextQuestion.QUESTION_TYPE)) {
					questionSet.add(new OrderedMultiTextQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(PictureResponseQuestion.QUESTION_TYPE)) {
					questionSet.add(new PictureResponseQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(ResponseQuestion.QUESTION_TYPE)) {
					questionSet.add(new ResponseQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(UnorderedMultiTextQuestion.QUESTION_TYPE)) {
					questionSet.add(new UnorderedMultiTextQuestion(rs.getInt("id"),this.getConnection()));
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return questionSet;
	}
	
	public int getMaxScore(){
		int totalScore = 0;
		for (Question currQuestion: this.getQuestions()) {
			totalScore += currQuestion.getMaxScore();
		}
		return totalScore;
	}
		
	//methods for adding different question types
	
	public void addFillInTheBlankQuestion(String backgroundText, String questionText, ArrayList<String> actualAnswers){
		FillInTheBlankQuestion newQuestion = new FillInTheBlankQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, actualAnswers);
	}
	
	public void addMatchingQuestion(String backgroundText, String questionText, ArrayList<String> possibleAnswers, ArrayList<String> actualAnswers){
		MatchingQuestion newQuestion = new MatchingQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, possibleAnswers, actualAnswers);
	}
	
	public void addMultiMultipleChoiceQuestion(String backgroundText, String questionText, ArrayList<String> possibleAnswers, ArrayList<Integer> actualAnswers){
		MultiMultipleChoiceQuestion newQuestion = new MultiMultipleChoiceQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, possibleAnswers, actualAnswers);
	}
	
	public void addMultipleChoiceQuestion(String backgroundText, String questionText, ArrayList<String> possibleAnswers, int actualAnswer){
		MultipleChoiceQuestion newQuestion = new MultipleChoiceQuestion(0,this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, possibleAnswers, actualAnswer);
	}
	
	public void addOrderedMultiTextQuestion(String backgroundText, String questionText, ArrayList<ArrayList<String>> actualAnswers){
		OrderedMultiTextQuestion newQuestion = new OrderedMultiTextQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, actualAnswers);
	}
	
	public void addPictureResponseQuestion(String backgroundText, String questionText, String pictureURL, ArrayList<String> actualAnswers){
		PictureResponseQuestion newQuestion = new PictureResponseQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, pictureURL, actualAnswers);
	}
	
	public void addResponseQuestion(String backgroundText, String questionText, ArrayList<String> actualAnswers){
		ResponseQuestion newQuestion = new ResponseQuestion(0,this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, actualAnswers);
	}
	
	public void addUnorderedMultiTextQuestion(String backgroundText, String questionText, ArrayList<ArrayList<String>> actualAnswers){
		UnorderedMultiTextQuestion newQuestion = new UnorderedMultiTextQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, actualAnswers);
	}
	
	
	//methods for basic quiz functionality
	
	public void clearHistory() {
		this.setInt("highest_score", 0);
		this.setInt("lowest_score", 0);
		this.setLong("longest_time", 0);
		this.setLong("shortest_time", 0);
		this.setLong("average_time", 0);
		this.setInt("mean_score", 0);
		this.setInt("total_times_taken", 0);
		this.setLong("total_time_spent_on_quiz", 0);
		this.setCSV("most_recent_csv", new ArrayList<String>());
		this.setCSV("best_all_time_csv", new ArrayList<String>());
		this.setCSV("best_interval_csv", new ArrayList<String>());
	}
	

	public void quizTaken(Score score) {
		if (score != null) {
			if (score.getNumericalScore() > this.getHighestScore()) this.setInt("highest_score", score.getNumericalScore());
			if (this.getLowestScore() < 0 || score.getNumericalScore() < this.getLowestScore()) this.setInt("lowest_score", score.getNumericalScore());
			if (score.getDuration() > this.getLongestTime()) this.setLong("longest_time", score.getDuration());
			if (this.getShortestTime() < 0 || score.getDuration() < this.getShortestTime()) this.setLong("shortest_time", score.getDuration());
			long averageTime = (this.getAverageTime() * this.getTotalTimesTaken() + score.getDuration()) / (this.getTotalTimesTaken() + 1);
			this.setLong("average_time", averageTime);
			int meanScore = (this.getMeanScore() * this.getTotalTimesTaken() + score.getNumericalScore()) / (this.getTotalTimesTaken() + 1);
			this.setInt("mean_score", meanScore);
			this.setInt("total_times_taken", this.getTotalTimesTaken() + 1);
			this.setLong("total_time_spent_on_quiz", this.getLong("total_time_spent_on_quiz") + score.getDuration());
			
			this.updateMostRecentScores(score);
			this.updateBestAllTimeScores(score);
			this.updateBestIntervalScoreIds(score);
		}
	}
	
	private void updateMostRecentScores(Score score) {
		ArrayList<Integer> mostRecentScoreIds = this.getIntCSV("most_recent_csv");
		mostRecentScoreIds.add(score.getID());
		while (mostRecentScoreIds.size() > NUM_HISTORICAL_SCORES) {
			mostRecentScoreIds.remove(NUM_HISTORICAL_SCORES);
		}
		this.setCSV("most_recent_csv", mostRecentScoreIds);
	}
	
	private void updateBestAllTimeScores(Score score) {
		ArrayList<Integer> bestAllTimeScoreIds = this.getIntCSV("best_all_time_csv");
		ArrayList<Score> bestAllTimeScores = new ArrayList<Score>();
		for (int scoreId : bestAllTimeScoreIds) {
			bestAllTimeScores.add(new Score(scoreId, this.getConnection()));
		}
		bestAllTimeScores.add(score);
		
		Collections.sort(bestAllTimeScores);
		while (bestAllTimeScores.size() > NUM_HISTORICAL_SCORES) {
			bestAllTimeScores.remove(NUM_HISTORICAL_SCORES);
		}
		
		bestAllTimeScoreIds.clear();
		for (Score historicalScore : bestAllTimeScores) {
			bestAllTimeScoreIds.add(historicalScore.getID());
		}
		
		this.setCSV("best_all_time_csv", bestAllTimeScoreIds);
	}
	
	private void updateBestIntervalScoreIds(Score score) {
		ArrayList<Integer> bestIntervalScoreIds = this.getIntCSV("best_interval_csv");
		ArrayList<Score> bestIntervalScores = new ArrayList<Score>();
		for (int scoreId : bestIntervalScoreIds) {
			bestIntervalScores.add(new Score(scoreId, this.getConnection()));
		}
		
		long latestPossibleStartTime = System.currentTimeMillis() - RANKING_DISPLAY_TIME_INTERVAL;
		for (int index = 0; index < bestIntervalScores.size(); index++) {
			if (bestIntervalScores.get(index).getDateTaken() < latestPossibleStartTime) {
				bestIntervalScores.remove(index);
				index--;
			}
		}
		
		bestIntervalScores.add(score);
		
		Collections.sort(bestIntervalScores);
		while (bestIntervalScores.size() > NUM_HISTORICAL_SCORES) {
			bestIntervalScores.remove(NUM_HISTORICAL_SCORES);
		}
		
		bestIntervalScoreIds.clear();
		for (Score historicalScore : bestIntervalScores) {
			bestIntervalScoreIds.add(historicalScore.getID());
		}
		
		this.setCSV("best_interval_csv", bestIntervalScoreIds);
	}
	
	@Override
	public String getTableName() {
		return "quizzes";
	}
	
}
