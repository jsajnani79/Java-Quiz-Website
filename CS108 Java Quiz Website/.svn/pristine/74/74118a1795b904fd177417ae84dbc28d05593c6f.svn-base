package QuizProject.QuizPackage;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;

import QuizProject.DBConnection;
import QuizProject.ModelObject;
import QuizProject.QuestionPackage.FillInTheBlankQuestion;
import QuizProject.QuestionPackage.MatchingQuestion;
import QuizProject.QuestionPackage.MultiMultipleChoiceQuestion;
import QuizProject.QuestionPackage.MultipleChoiceQuestion;
import QuizProject.QuestionPackage.OrderedMultiTextQuestion;
import QuizProject.QuestionPackage.PictureResponseQuestion;
import QuizProject.QuestionPackage.Question;
import QuizProject.QuestionPackage.ResponseQuestion;
import QuizProject.QuestionPackage.UnorderedMultiTextQuestion;
import QuizProject.UserPackage.User;

public class Quiz extends ModelObject {
	
	
	//static final constants
	
	private static final int RANKING_DISPLAY_TIME_INTERVAL = 1000 * 60 * 60 * 24 * 15;
	private static final int NUM_HISTORICAL_SCORES = 10;
	private static final int NUM_RECENT_QUIZZES = 3;
	private static final String SCORE_SORT_DESCRIPTOR = "numerical_score DESC, duration ASC";
	private static final String REVERSE_SCORE_SORT_DESCRIPTOR = "numerical_score ASC, duration DESC";
	
	
	//constructors
	
	public Quiz(int id, DBConnection connection) {
		super(id, connection);
	}
	
	public void createModelObject(String name, String description, int creatorId, boolean random, boolean multiPage, boolean immediateCorrection, int categoryId, boolean canTakePracticeMode) {
		this.createModelObject(name, description, creatorId, random, multiPage, immediateCorrection, categoryId, canTakePracticeMode, null);
	}
	
	protected void createModelObject(String name, String description, int creatorId, boolean random, boolean multiPage, boolean immediateCorrection, int categoryId, boolean canTakePracticeMode, ArrayList<Object> additionalParameters) {
		long dateCreated = System.currentTimeMillis();
		ArrayList<Object> parameters = new ArrayList<Object>(Arrays.asList(name, description, creatorId, -1, -1, -1, -1, -1, -1, 0, 0, new ArrayList<String>(), new ArrayList<String>(), new ArrayList<String>(), dateCreated, random, multiPage, categoryId, immediateCorrection, false, canTakePracticeMode));
		
		if (additionalParameters != null) {
			parameters.addAll(additionalParameters);
		}
		
		super.createModelObject(parameters);
	}
	
	public static int getIdForName(String name, DBConnection connection) {
		int id = 0;
		
		ResultSet rs = connection.executeQuery("SELECT * FROM quizzes WHERE name = \"" + name + "\";");
		try {
			if (rs.next()) {
				id = rs.getInt("id");
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return id;
	}
	
	public static ArrayList<Quiz> getMostPopularQuizzes(DBConnection connection) {
		ArrayList<Quiz> quizzes = new ArrayList<Quiz>();
		
		int quizCount = 0;
		ResultSet rs = connection.executeQuery("SELECT * FROM quizzes ORDER BY total_times_taken DESC");
		try {
			while (quizCount < NUM_RECENT_QUIZZES && rs.next()) {
				quizzes.add(new Quiz(rs.getInt("id"), connection));
				quizCount++;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
				
		return quizzes;
	}
	
	public static ArrayList<Quiz> getRecentlyCreatedQuizzes(DBConnection connection) {
		ArrayList<Quiz> quizzes = new ArrayList<Quiz>();
		int quizCount = 0;
		ResultSet rs = connection.executeQuery("SELECT * FROM quizzes ORDER BY date_created DESC");
		try {
			while (quizCount < NUM_RECENT_QUIZZES && rs.next()) {
				quizzes.add(new Quiz(rs.getInt("id"), connection));
				quizCount++;
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
				
		return quizzes;
	}
	
	public static ArrayList<Quiz> getAllQuizzes(DBConnection connection) {
		ArrayList<Quiz> quizzes = new ArrayList<Quiz>();
		ResultSet rs = connection.executeQuery("SELECT * FROM quizzes ORDER BY date_created DESC");
		try {
			while (rs.next()) {
				quizzes.add(new Quiz(rs.getInt("id"), connection));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
				
		return quizzes;
	}
	
	//getters and setters for quiz properties 

	public String getName() {
		return this.getString("name");
	}
	
	public void setName(String name) {
		this.setString("name", name);
	}
	
	public String getDescription() {
		return this.getString("description");
	}
	
	public void setDescription(String description) {
		this.setString("description", description);
	}
	
	public User getCreator(){
		return new User(this.getInt("creator_id"), this.getConnection());
	}
	
	public long getDateCreated() {
		return this.getLong("date_created");
	}
	
	public boolean isRandom() {
		return this.getBoolean("is_random");
	}
	
	public boolean isMultiPage() {
		return this.getBoolean("is_multi_page");
	}
	
	public boolean immediateCorrection() {
		return this.getBoolean("immediate_correction");
	}
	
	public boolean canTakePracticeMode() {
		return this.getBoolean("can_take_practice_mode");
	}
	
	// Stats
	
	public int getHighestScore() {
		return (int) this.getExtremum("numerical_score", SCORE_SORT_DESCRIPTOR);
	}
	
	public int getLowestScore() {
		return (int) this.getExtremum("numerical_score", REVERSE_SCORE_SORT_DESCRIPTOR);
	}
	
	public long getLongestTime() {
		return this.getExtremum("duration", "duration ASC");
	}
	
	public long getShortestTime() {
		return this.getExtremum("duration", "duration DESC");
	}
	
	public long getAverageTime() {
		return this.getMean("duration");
	}
	
	public int getMeanScore() {
		return (int) this.getMean("numerical_score");
	}
	
	/**
	 * This only works for columns whose value when correct should be non-negative. Score
	 * and duration fit this constraint.
	 * @param min
	 * @param valueName
	 * @return
	 */
	private long getExtremum(String valueName, String sortDescriptor) {
		if (sortDescriptor == null) sortDescriptor = "";
		else sortDescriptor = " ORDER BY " + sortDescriptor;
		
		long extremum = -1;
		
		ResultSet rs = this.getConnection().executeQuery("SELECT * FROM scores WHERE quiz_id = " + this.getID() + sortDescriptor + " LIMIT 1;");
		try {
			if (rs.next()) {
				extremum = rs.getLong(valueName);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return extremum;
	}
	
	/**
	 * This only works for columns whose value when correct should be non-negative. Score
	 * and duration fit this constraint.
	 * @param valueName
	 * @return
	 */
	private long getMean(String valueName) {
		long mean = -1;
		
		ResultSet rs = this.getConnection().executeQuery("SELECT * FROM scores WHERE quiz_id = " + this.getID() + " LIMIT 1;");
		try {
			if (rs.next()) {
				String paramName = "AVG(" + valueName + ")";
				rs = this.getConnection().executeQuery("SELECT " + paramName + " FROM scores WHERE quiz_id = " + this.getID() + ";");
				if (rs.next()) {
					mean = rs.getLong(paramName);
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return mean;
	}
	
	public int getTotalTimesTaken() {
		int count = 0;

		String paramName = "COUNT(numerical_score)";
		ResultSet rs = this.getConnection().executeQuery("SELECT " + paramName + " FROM scores WHERE quiz_id = " + this.getID() + ";");
		try {
			if (rs.next()) {
				count = rs.getInt(paramName);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}

		return count;
	}
	
	public int getTotalTimeSpentOnQuiz() {
		int sum = 0;

		String paramName = "SUM(duration)";
		ResultSet rs = this.getConnection().executeQuery("SELECT " + paramName + " FROM scores WHERE quiz_id = " + this.getID() + ";");
		try {
			if (rs.next()) {
				sum = rs.getInt(paramName);
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}

		return sum;
	}
	
	private ArrayList<Integer> getScoreIds(String predicate, String sortDescriptor) {
		if (predicate == null) predicate = "";
		else predicate += " AND ";
		
		if (sortDescriptor == null) sortDescriptor = "";
		else sortDescriptor = " ORDER BY " + sortDescriptor;
		
		ArrayList<Integer> scoreIds = new ArrayList<Integer>();
		
		ResultSet rs = this.getConnection().executeQuery("SELECT * FROM scores WHERE " + predicate + "quiz_id = " + this.getID() + sortDescriptor + " LIMIT " + NUM_HISTORICAL_SCORES + ";");
		try {
			while (rs.next()) {
				scoreIds.add(rs.getInt("id"));
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		
		return scoreIds;
	}
	
	private ArrayList<Score> getScores(String predicate, String sortDescriptor) {
		ArrayList<Score> scores = new ArrayList<Score>();
		
		ArrayList<Integer> scoreIds = this.getScoreIds(predicate, sortDescriptor);
		for (Integer scoreId : scoreIds) {
			Score score = new Score(scoreId, this.getConnection());
			scores.add(score);
		}
		
		return scores;
		
	}
	
	public ArrayList<Score> getMostRecentScores() {
		return this.getScores(null, "date_taken DESC");
	}
	
	public ArrayList<Score> getBestAllTimeScores() {
		return this.getScores(null, SCORE_SORT_DESCRIPTOR);
	}
	
	public ArrayList<Score> getBestIntervalScores(){
		return this.getScores("date_taken > " + (System.currentTimeMillis() - RANKING_DISPLAY_TIME_INTERVAL), SCORE_SORT_DESCRIPTOR);
	}
	
	public ArrayList<Question> getQuestions() {
		ArrayList<Question> questionSet = new ArrayList<Question>();
		ResultSet rs = this.getConnection().executeQuery("SELECT *"  + " FROM questions WHERE quiz_id = " + this.getID() + ";");
		try {
			while (rs.next()) {
				String questionType = rs.getString("question_type");
				if (questionType.equals(FillInTheBlankQuestion.QUESTION_TYPE)) {
					questionSet.add(new FillInTheBlankQuestion(rs.getInt("id"),this.getConnection()));
				}else if (questionType.equals(MatchingQuestion.QUESTION_TYPE)) {
					questionSet.add(new MatchingQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(MultiMultipleChoiceQuestion.QUESTION_TYPE)) {
					questionSet.add(new MultiMultipleChoiceQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(MultipleChoiceQuestion.QUESTION_TYPE)) {
					questionSet.add(new MultipleChoiceQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(OrderedMultiTextQuestion.QUESTION_TYPE)) {
					questionSet.add(new OrderedMultiTextQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(PictureResponseQuestion.QUESTION_TYPE)) {
					questionSet.add(new PictureResponseQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(ResponseQuestion.QUESTION_TYPE)) {
					questionSet.add(new ResponseQuestion(rs.getInt("id"),this.getConnection()));
				} else if (questionType.equals(UnorderedMultiTextQuestion.QUESTION_TYPE)) {
					questionSet.add(new UnorderedMultiTextQuestion(rs.getInt("id"),this.getConnection()));
				}
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return questionSet;
	}
	
	public int getMaxScore(){
		int totalScore = 0;
		for (Question currQuestion: this.getQuestions()) {
			totalScore += currQuestion.getMaxScore();
		}
		return totalScore;
	}
		
	// methods for adding different question types
	
	public void addFillInTheBlankQuestion(String backgroundText, String questionText, ArrayList<String> actualAnswers){
		FillInTheBlankQuestion newQuestion = new FillInTheBlankQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, actualAnswers);
	}
	
	public void addMatchingQuestion(String backgroundText, String questionText, ArrayList<String> possibleAnswers, ArrayList<String> actualAnswers){
		MatchingQuestion newQuestion = new MatchingQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, possibleAnswers, actualAnswers);
	}
	
	public void addMultiMultipleChoiceQuestion(String backgroundText, String questionText, ArrayList<String> possibleAnswers, ArrayList<Integer> actualAnswers){
		MultiMultipleChoiceQuestion newQuestion = new MultiMultipleChoiceQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, possibleAnswers, actualAnswers);
	}
	
	public void addMultipleChoiceQuestion(String backgroundText, String questionText, ArrayList<String> possibleAnswers, int actualAnswer){
		MultipleChoiceQuestion newQuestion = new MultipleChoiceQuestion(0,this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, possibleAnswers, actualAnswer);
	}
	
	public void addOrderedMultiTextQuestion(String backgroundText, String questionText, ArrayList<ArrayList<String>> actualAnswers){
		OrderedMultiTextQuestion newQuestion = new OrderedMultiTextQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, actualAnswers);
	}
	
	public void addPictureResponseQuestion(String backgroundText, String questionText, String pictureURL, ArrayList<String> actualAnswers){
		PictureResponseQuestion newQuestion = new PictureResponseQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, pictureURL, actualAnswers);
	}
	
	public void addResponseQuestion(String backgroundText, String questionText, ArrayList<String> actualAnswers){
		ResponseQuestion newQuestion = new ResponseQuestion(0,this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, actualAnswers);
	}
	
	public void addUnorderedMultiTextQuestion(String backgroundText, String questionText, ArrayList<ArrayList<String>> actualAnswers){
		UnorderedMultiTextQuestion newQuestion = new UnorderedMultiTextQuestion(0, this.getConnection());
		newQuestion.createModelObject(this.getID(), backgroundText, questionText, actualAnswers);
	}
		
	public void clearHistory() {
		this.getConnection().executeUpdate("DELETE FROM scores WHERE quiz_id = " + this.getID());
	}
	
	@Override
	public String getTableName() {
		return "quizzes";
	}
	
}
